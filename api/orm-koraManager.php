<?php

namespace KoraORM;

/**
 * The KoraManager class represents a single connection to a Kora backend.
 * 
 * In order to gain access to KoraEntities, one should use the methods found in
 * this class. These methods will take steps to make sure that if you get two
 * objects representing the same record in Kora, then they will use the same
 * memory.
 * 
 * @author Zachary Pepin <zachary.pepin@matrix.msu.edu>
 *
 */
class KoraManager
{
	/**
	 * The Kora search token this instance will use when interacting with the
	 * Kora backend.
	 * 
	 * @var string
	 */
	private $searchToken = null;
	
	/**
	 * A cache for the data obtained from inspecting the Kora backend since
	 * this could be accessed many times.
	 * 
	 * This metadata includes the projects, schemes, and controls available to
	 * this instance as well as some information about them.
	 * 
	 * @var array
	 */
	private $koraCache = array();
	
	/**
	 * A cache for all the metadata obtained from loading custom KoraControls
	 * and KoraEntities, as well as the metadata generated automatically from
	 * the information stored within Kora.
	 * 
	 * This cache is accessed many times during the lifetime of this instance.
	 * It contains information about all the custom KoraControls and
	 * KoraEntities which were loaded. It also contains default metadata which
	 * is automatically generated by inspecting the Kora backend.
	 * 
	 * @var array
	 */
	private $metadataCache = array(
			'objects' => array(
					'all' => array(),
					'hashed' => array()
					),
			'controls' => array(
					'all' => array(),
					'hashed' => array()
					)
			);
	
	/**
	 * A data structure to keep track on all of the KoraEntities which have been
	 * created.
	 * 
	 * This is important for identifying objects which are requested multiple
	 * times. It is used so that this instance can return the same object in
	 * memory everytime it is requested.
	 * 
	 * @var array
	 */
	private $objectCache = array();
	
	/**
	 * Create a new KoraManager using the given Kora search token.
	 * 
	 * @param string $searchToken the search token the KoraManager will use
	 */
	public function __construct($searchToken)
	{
		$this->searchToken = $searchToken;
		
		// load all the custom controls and objects
		$this->registerControls();
		$this->registerEntities();
	}
	
	public function __get($name)
	{
		if ($name == 'searchToken')
			return $this->searchToken;
		
		$trace = debug_backtrace();
		trigger_error(
				'Undefined property: ' . $name .
				' in ' . $trace[0]['file'] .
				' on line ' . $trace[0]['line'],
				E_USER_NOTICE);
		
		return null;
	}
	
	public function __isset($name)
	{
		if ($name == 'searchToken')
			return isset($this->searchToken);
		return false;
	}
	
	/**
	 * Create or retrieve an existing KoraEntity with the given KID.
	 * 
	 * If a KoraEntity was previously created with the given KID, a reference
	 * to the pre-existing KoraEntity is returned. Otherwise, a new
	 * KoraEntity is created.
	 * 
	 * If <code>$checkExists</code> is true, then a Kora Search is preformed to
	 * confirm that the corresponding record does in fact exist before creating
	 * a new KoraEntity.
	 * 
	 * If some data is specific, then the KoraEntity which is created with
	 * initially populated with that data. In this case, data should contain
	 * all of the fields the object may need during its lifetime.
	 * 
	 * @param mixed $kid the KID of the object to create
	 * @param boolean $checkExists whether to check if the KID exists in Kora first
	 * @param mixed $data the Kora data for the object, usually retrieved via a Kora search
	 * @return <code>false</code> on failure, a KoraEntity with the KID on success
	 */
	private function createKoraEntity($kid, $checkExists=true, $data=false)
	{
		// normalize the Kid
		if (($kid = self::parseKid($kid)) === false)
			return false;
		
		// check if the object is in the cache
		if (!isset($this->objectCache[$kid['kid']]))
		{
			// check if the Kid exists in Kora
			if ($checkExists)
			{
				$results = KORA_Search( $this->searchToken, $kid['project'], $kid['scheme'],
						new \KORA_Clause('KID', '=', $kid['kid']),
						'ALL',
						array( array( 'field' => 'kid', 'direction' => SORT_ASC ) )
				);
				if (empty($results))
					return false;
				// might as well save the results
				$data = $results[$kid['kid']];
			}
			
			// search for an appropriate object
			$classname = "\\KoraORM\\KoraEntity";
			if (($ometa = $this->getObjectMetadata($kid['project'], $kid['scheme'])) !== false && isset($ometa['classname']))
				$classname = $ometa['classname'];
			
			// create the new object and add it to the cache
			if ($data === false)
				$this->objectCache[$kid['kid']] = new $classname($this, $kid);
			else
				$this->objectCache[$kid['kid']] = new $classname($this, $kid, $data);
		}
		return $this->objectCache[$kid['kid']];
	}
	
	/**
	 * Retrieve a KoraEntity with the specified KID.
	 * 
	 * If another KoraEntity with that KID was previously created, a reference
	 * to that KoraEntity is returned, otherwise, a new KoraEntity with the KID
	 * is created and then returned.
	 * 
	 * If <code>$checkExists</code> is true, then a Kora search is performed to
	 * ensure the object exists within Kora before create a new object.
	 * 
	 * @param mixed $kid the KID of the KoraEntity to retrieve
	 * @param boolean $checkExists whether to check if the KID exists in Kora first
	 * @return a KoraEntity instance on success, <code>false</code> on failure
	 */
	public function getByKid($kid, $checkExists=true)
	{
		return $this->createKoraEntity($kid, $checkExists);
	}
	
	/**
	 * Perform a Kora search.
	 * 
	 * The use of this method is very similar to KORA_Search
	 *  
	 * @param int $projectID the ID of the project to be searched
	 * @param int $schemeID the ID of the scheme to be searched
	 * @param KORA_Clause $queryClause a KORA_Clause object representing the query
	 * @param array $orderBy an orderBy array as in KORA_Search
	 * @param int $limitStart as in KORA_Search
	 * @param int $limitNum as in KORA_Search
	 * @return an array of KoraEntities on success, <code>null</code> on failure
	 */
	public function search($projectID, $schemeID, $queryClause, $fields='ALL',$orderBy=array(), $limitStart=0, $limitNum=0)
	{
		$results = KORA_Search($this->searchToken, $projectID, $schemeID, $queryClause, $fields, $orderBy, $limitStart, $limitNum);
		$entities = array();
		foreach ($results as $row)
			$entities[] = $this->createKoraEntity($row['kid'], false, $row);
		return $entities;
	}
	
	/**
	 * Determine which projects in Kora are available to this instance.
	 * 
	 * @return an array of associative arrays representing the available projects
	 */
	public function getAvailableProjects()
	{
		if (!isset($this->koraCache['projects']))
		{
			$projects = array();
			foreach (getProjectInfoFromToken($this->searchToken) as $name => $info)
			{
				$projects[] = array( 'name' => $name, 'pid' => $info['pid'] );
			}
			return $projects;
		}
		return $this->koraCache['projects'];
	}
	
	/**
	 * Determine if a given project in Kora is available to this instance.
	 * 
	 * @param int $pid the ID of the project
	 * @return boolean
	 */
	public function isProjectAvailable($pid)
	{
		$pid = intval($pid);
		foreach ($this->getAvailableProjects() as $p)
		{
			if ($p['pid'] == $pid)
			{
				return true;
			}
		}
		return false;
	}
	
	/**
	 * Determine which schemes of a given project in Kora are available to
	 * this instance.
	 * 
	 * @param int $pid the ID of the project
	 * @return an array of associative arrays representing the different
	 * schemes on success, <code>false</code> on failure
	 */
	public function getAvailableSchemes($pid)
	{
		$pid = intval($pid);
		if (!isset($this->koraCache['schemes']))
			$this->koraCache['schemes'] = array();
		if (!isset($this->koraCache['schemes'][$pid]))
		{
			$projects = getProjectInfoFromToken($this->searchToken);
			$found = false;
			foreach (getProjectInfoFromToken($this->searchToken) as $pname => $pinfo)
			{
				if ($pinfo['pid'] == $pid)
				{
					$schemes = array();
					foreach ($pinfo['schemes'] as $sname => $sid)
					{
						$schemes[] = array( 'name' => $sname, 'sid' => $sid);
					}
					$this->koraCache['schemes'][$pid] = $schemes;
					$found = true;
					break;
				}
			}
			if (!$found)
				return false;
		}
		return $this->koraCache['schemes'][$pid];
	}
	
	/**
	 * Determine if a given scheme in Kora is available to this instance.
	 * 
	 * @param int $pid the ID of the project
	 * @param int $sid the ID of the scheme
	 * @return boolean
	 */
	public function isSchemeAvailable($pid, $sid)
	{
		$pid = intval($pid);
		$sid = intval($sid);
		if (!$this->isProjectAvailable($pid))
			return false;
		foreach ($this->getAvailableSchemes($pid) as $s)
		{
			if ($s['sid'] == $sid)
			{
				return true;
			}
		}
		return false;
	}
	
	/**
	 * Determine which controls in a given scheme in Kora are available to
	 * this instance.
	 * 
	 * @param int $pid the ID of the project
	 * @param int $sid the ID of the scheme
	 * @return an array of associative arrays representing the controls on
	 * success, <code>false</code> on failure
	 */
	public function getAvailableControls($pid, $sid)
	{
		global $db;
		$pid = intval($pid);
		$sid = intval($sid);
		if (!isset($this->koraCache['controls']))
			$this->koraCache['controls'] = array();
		if (!isset($this->koraCache['controls'][$pid]))
		{
			if (!$this->isProjectAvailable($pid))
				return false;
			$this->koraCache['controls'][$pid] = array();
		}
		if (!isset($this->koraCache['controls'][$pid][$sid]))
		{
			if (!$this->isSchemeAvailable($pid, $sid))
				return false;
			
			//
			// This next section is a bit hackish since I couldn't find a
			// method available to Kora clients that offered this
			// functionality.
			//
			// Essentially, I wanted the ability to inspect the controls in a
			// scheme, especially to see their name and type. Using this
			// information, I can then create more sensible default mappings
			// from controls in Kora to KoraControl objects.
			//
			
			$cTable = 'p' . $pid . 'Control';
			
			$controlQuery =  "SELECT $cTable.name AS name, $cTable.cid AS cid, $cTable.collid AS collid, $cTable.sequence AS sequence, ";
			$controlQuery .= "$cTable.description AS description, $cTable.type AS type, $cTable.publicEntry AS publicEntry, $cTable.required AS required, ";
			$controlQuery .= "$cTable.showInResults AS privateResults, $cTable.showInPublicResults as publicResults, $cTable.searchable AS searchable, $cTable.advSearchable AS advSearchable ";
			$controlQuery .= "FROM $cTable LEFT JOIN collection USING (collid) ";
			$controlQuery .= /*"LEFT JOIN control ON ($cTable.type = control.class)"*/ " WHERE $cTable.schemeid=";
			$controlQuery .= escape($sid)." ORDER BY collection.sequence, $cTable.sequence";
			
			$controlQuery = $db->query($controlQuery);
			$controls = array();
			while ($c = $controlQuery->fetch_assoc())
			{
				$controls[] = $c;
			}
			$this->koraCache['controls'][$pid][$sid] = $controls;
		}
		return $this->koraCache['controls'][$pid][$sid];
	}
	
	/**
	 * Determine if a given control in Kora is available to this instance.
	 * 
	 * @param int $pid the ID of the project
	 * @param int $sid the ID of the scheme
	 * @param int $cid the ID of the control
	 * @return boolean
	 */
	public function isControlAvailable($pid, $sid, $cid)
	{
		$pid = intval($pid);
		$sid = intval($sid);
		$cid = intval($cid);
		if (!$this->isSchemeAvailable($pid, $sid))
			return false;
		foreach ($this->getAvailableControls($pid, $sid) as $c)
		{
			if ($c['cid'] == $cid)
			{
				return true;
			}
		}
		return false;
	}
	
	/**
	 * Retrieve metadata about the KoraEntity associated with a specified
	 * scheme.
	 * 
	 * @param int $pid the ID of the project
	 * @param int $sid the ID of the scheme
	 * @return an associative array of metadata on success, <code>false</code>
	 * on failure
	 */
	public function getObjectMetadata($pid, $sid)
	{
		// santize inputs
		$pid = intval($pid);
		$sid = intval($sid);
		// check if the scheme is available to this instance
		if (!$this->isSchemeAvailable($pid, $sid))
			return false;
		// check if the metadata has already been cached
		if (!isset($this->metadataCache['objects']['hashed'][$pid]))
			$this->metadataCache['objects']['hashed'][$pid] = array();
		if (!isset($this->metadataCache['objects']['hashed'][$pid][$sid]))
		{
			// default metadata for a scheme
			$cachedmeta = array(
					'project' => $pid,
					'scheme' => $sid,
					'controls' => array()
					);
			// check the controls of the scheme and generate some metadata for them
			foreach ($this->getAvailableControls($pid, $sid) as $c)
			{
				$cmeta = array(
						'name' => $c['name'],
						'koraName' => $c['name'],
						'koraType' => $c['type'],
						'searchable' => $c['searchable'] == '1',
						'advSearchable' => $c['advSearchable'] == '1'
						);
				// check if there is a KoraControl registered to handle the Kora type
				if (isset($this->metadataCache['controls']['hashed'][$cmeta['koraType']]))
					$cmeta['type'] = $this->metadataCache['controls']['hashed'][$cmeta['koraType']];
				$cachedmeta['controls'][$cmeta['koraName']] = $cmeta;
			}
			// add it to the cache for later
			$this->metadataCache['objects']['hashed'][$pid][$sid] = $cachedmeta;
		}
		return $this->metadataCache['objects']['hashed'][$pid][$sid];
	}
	
	/**
	 * Load the custom KoraControls.
	 * 
	 * This method will scan the controls directory for php files and will load
	 * the custom KoraControls found within them. This includes parsing their
	 * metadata for easy retrieval later.
	 */
	private function registerControls()
	{
		// open the controls directory
		foreach (scandir(KORA_ORM_CONTROLS_DIR) as $file)
		{
			// We are going to assume that the name of the custom
			// KoraControl class is going to match the name of the PHP
			// file. As such, we are going to check if the filename is
			// a file, and whether it follows PHP naming conventions.
			$fullname = KORA_ORM_CONTROLS_DIR . DIRECTORY_SEPARATOR . $file;
			if (is_file($fullname) && preg_match("/^[a-zA-Z_\\x7f-\\xff][a-zA-Z0-9_\\x7f-\\xff]*\\.php$/", $file))
			{
				// extracting the name of the custom KoraControl class
				$classname = "\\KoraORM\\Controls\\" . substr($file, 0, strlen($file) - 4);
				// including the custom KoraControl
				require_once( $fullname );
				// loading the custom KoraControl's metadata
				$metadata = $classname::loadMetadata();
				
				// generate the full metadata based off the partial
				// metadata found in the KoraControl class.
				$cachedmeta = array(
						'classname' => $classname
						);
				if (isset($metadata['koraType']))
					$cachedmeta['koraType'] = strval($metadata['koraType']);
				
				// add the metadata to the cache
				$this->metadataCache['controls']['all'][$classname] = $cachedmeta;
				if (isset($cachedmeta['koraType']))
					$this->metadataCache['controls']['hashed'][$cachedmeta['koraType']] = $cachedmeta;
			}
		}
	}
	
	/**
	 * Load the custom KoraEntities.
	 * 
	 * This method will scan the entities directory for php files and will load
	 * the custom KoraControls found within them. This includes parsing their
	 * metadata for easy retrieval later.
	 */
	private function registerEntities()
	{
		// open the entities directory
		foreach (scandir(KORA_ORM_ENTITIES_DIR) as $file)
		{
			// We are going to assume that the name of the custom
			// KoraEntity class is going to match the name of the PHP
			// file. As such, we are going to check if the filename is
			// a file, and whether it follows PHP naming conventions.
			$fullname = KORA_ORM_ENTITIES_DIR . DIRECTORY_SEPARATOR . $file;
			if (is_file($fullname) && preg_match("/^[a-zA-Z_\\x7f-\\xff][a-zA-Z0-9_\\x7f-\\xff]*\\.php$/", $file))
			{
				// extracting the name of the custom KoraEntity class
				$classname = "\\KoraORM\\Entities\\" . substr($file, 0, strlen($file) - 4);
				// including the custom KoraEntity
				require_once( $fullname );
				// loading the custom KoraControl's metadata
				$metadata = $classname::loadMetadata();
				
				// generate the full metadata based off the partial
				// metadata found in the custom KoraEntity class.
				$cachedmeta = null;
				if (!isset($metadata['project']) || !isset($metadata['scheme'])
						|| ($cachedmeta = $this->getObjectMetadata($metadata['project'], $metadata['scheme'])) === false)
				{
					$cachedmeta = array( 'controls' => array() );
				}
				$cachedmeta['classname'] = $classname;
				
				// merge preexisting control metadata with custom control metadata
				if (isset($metadata['controls']))
				{
					// changing the keys of the control metadata to be the Kora
					// type of the control for easy merging
					$controlmeta = array();
					foreach ($cachedmeta['controls'] as $cname => $cmeta)
						$controlmeta[$cmeta['koraName']] = $cmeta;

					foreach ($metadata['controls'] as $cname => $cmeta)
					{
						if (isset($cmeta['koraName']))
						{
							if (!isset($controlmeta[$cmeta['koraName']]))
								$controlmeta[$cmeta['koraName']] = array( 'koraName' => $cmeta['koraName'] );
							$controlmeta[$cmeta['koraName']]['name'] = $cname;
							if (isset($cmeta['searchable']))
								$controlmeta[$cmeta['koraName']]['searchable'] = $cmeta['searchable'];
							if (isset($cmeta['advSearchable']))
								$controlmeta[$cmeta['koraName']]['advSearchable'] = $cmeta['advSearchable'];
							// check if a matching control has been registered
							if (isset($cmeta['type']) && isset($this->metadataCache['controls']['all'][$cmeta['type']]))
								$controlmeta[$cmeta['koraName']]['type'] = $this->metadataCache['controls']['all'][$cmeta['type']];
						}
					}
					
					// changing the keys of the control metadata back to the
					// field name for easy lookups by KoraEntities
					$cachedmeta['controls'] = array();
					foreach ($controlmeta as $ckname => $cmeta)
						$cachedmeta['controls'][$cmeta['name']] = $cmeta;
				}
				
				// add it to the metadata cache
				$this->metadataCache['objects']['all'][$classname] = $cachedmeta;
				if (isset($cachedmeta['project']) && isset($cachedmeta['scheme']))
				{
					if (!isset($this->metadataCache['objects']['hashed'][$cachedmeta['project']]))
						$this->metadataCache['objects']['hashed'][$cachedmeta['project']] = array();
					$this->metadataCache['objects']['hashed'][$cachedmeta['project']][$cachedmeta['scheme']] = $cachedmeta;
				}
			}
		}
	}
	
	public function getSearchManager()
	{
		return new \KoraORM\SearchManager($this);
	}
	
	/**
	 * Parse a KID in multiple forms to a standardized form.
	 * 
	 * This method allows many methods to accept KIDs in several different
	 * forms. The provided KID may be a string KID, 3 hexadecimal numbers
	 * separated by -'s, an array containing this string in the index 'kid', or
	 * an array containg the project, scheme, and record ID's as ints.
	 * 
	 * @param mixed $kid the KID in some form
	 * @return a standardized KID
	 */
	public static function parseKid($kid)
	{
		if (is_string($kid))
		{
			$kid = strtoupper($kid);
			if (preg_match("/^[0-9A-F]+-[0-9A-F]+-[0-9A-F]+$/", $kid))
			{
				$fields = explode("-", $kid);
				return array(
						'project' => hexdec($fields[0]),
						'scheme' => hexdec($fields[1]),
						'record' => hexdec($fields[2]),
						'kid' => $kid);
			}
		}
		else if (is_array($kid))
		{
			if (isset($kid['kid']) && is_string($kid))
			{
				return self::parseKid($kid['kid']);
			} else if (isset($kid['project']) && is_int($kid['project'])
					&& isset($kid['scheme']) && is_int($kid['scheme'])
					&& isset($kid['record']) && is_int($kid['record']))
			{
				return array(
						'project' => $kid['project'],
						'scheme' => $kid['scheme'],
						'record' => $kid['record'],
						'kid' => strtoupper(dechex($kid['project']).'-'.dechex($kid['scheme']).'-'.dechex($kid['record'])));
			}
		}
		return false;
	}
}